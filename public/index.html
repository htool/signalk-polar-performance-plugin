<!DOCTYPE html>
<html>
<script type='text/javascript' src="./Chart.min.js"></script>
<script type='text/javascript' src="./jquery-3.7.1-min.js"></script>
<title>Polar performance</title>
<body style="background-color:#020202;">

<canvas id="myChart" style="width:100%;max-width:1200px"></canvas>

<script>

var polarSpeed, boatSpeed, TWA, TWS
var myChart, chartData

// --- CUSTOM PLUGIN: DRAW LABELS + FIX DOT LAYERING ---
Chart.plugins.register({
  afterDraw: function(chartInstance) {
    try {
      var ctx = chartInstance.chart.ctx;
      
      // 1. DRAW LABELS (These will cover lines and existing dots)
      chartInstance.data.datasets.forEach(function(dataset, i) {
        if (i < 2) return; // Skip dots loops
        
        var meta = chartInstance.getDatasetMeta(i);
        if (meta.hidden) return;

        var targetTWA = 125;
        var p1 = null, p2 = null;
        var p1Meta = null, p2Meta = null;

        // Find interpolation bracket
        for (var j = 0; j < dataset.data.length - 1; j++) {
            if (dataset.data[j].x <= targetTWA && dataset.data[j+1].x >= targetTWA) {
                p1 = dataset.data[j];
                p2 = dataset.data[j+1];
                p1Meta = meta.data[j]._model;
                p2Meta = meta.data[j+1]._model;
                break;
            }
        }

        var x, y;
        if (p1 && p2) {
            var ratio = (p2.x - p1.x === 0) ? 0 : (targetTWA - p1.x) / (p2.x - p1.x);
            x = p1Meta.x + (p2Meta.x - p1Meta.x) * ratio;
            y = p1Meta.y + (p2Meta.y - p1Meta.y) * ratio;
        } else {
            // Fallback to closest point
            var closest = null, minDiff = 100;
            dataset.data.forEach(function(d, idx) {
                var diff = Math.abs(d.x - targetTWA);
                if (diff < minDiff) { minDiff = diff; closest = meta.data[idx]._model; }
            });
            if (closest) { x = closest.x; y = closest.y; }
        }

        if (x > 0 && y > 0) {
            ctx.save();
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            var labelText = String(dataset.label);
            
            // Box
            var textWidth = ctx.measureText(labelText).width;
            ctx.fillStyle = "rgba(2,2,2,0.9)"; 
            ctx.fillRect(x - (textWidth/2) - 3, y - 9, textWidth + 6, 18);

            // Text
            ctx.fillStyle = dataset.borderColor || '#ffffff'; 
            ctx.fillText(labelText, x, y);
            ctx.restore();
        }
      });

      // 2. REDRAW DOTS (Datasets 0 and 1)
      // This forces the Polar/Boat Speed dots to appear ON TOP of the labels/boxes we just drew
      [0, 1].forEach(function(i) {
          var meta = chartInstance.getDatasetMeta(i);
          if (!meta.hidden) {
              // Iterate over every point in these datasets (usually just 1 point) and redraw it
              meta.data.forEach(function(point) {
                  point.draw();
              });
          }
      });

    } catch (err) {
      console.log("Label draw error: " + err);
    }
  }
});




$.getJSON("/plugins/signalk-polar-performance-plugin/chartData", function(json) {

  // 1. Add actual values dots to the BEGINNING (Indices 0 and 1)
  json.datasets.unshift({
    label: 'Polar Speed',
    backgroundColor: 'rgba(0,255,0,0.7)',
    borderColor: 'rgba(0,255,0,0.2)',
    borderWidth: 1,
    radius: 10, 
    pointStyle: 'circle',
    data: [{ y: 0, x: 0, r: 10 }]
  },
  {
    label: 'Boat Speed',
    backgroundColor: 'rgba(0,150,255,0.7)',
    borderColor: 'rgba(0,150,255,0.2)',
    borderWidth: 1,
    radius: 10,
    pointStyle: 'circle',
    data: [{ y: 0, x: 0, r: 10 }]
  })

  // 2. BACKUP ORIGINAL COLORS
  for (var i = 2; i < json.datasets.length; i++) {
      // If server didn't send a color, give it a default gray so our fading logic works
      if (!json.datasets[i].borderColor) {
          json.datasets[i].borderColor = 'rgba(100, 100, 100, 0.5)';
      }
      json.datasets[i]._originalColor = json.datasets[i].borderColor;
      json.datasets[i].borderWidth = 1; 
  }

  chartData = json
  showChart(chartData)
})

function showChart (data) {
  console.log(data)
  
  myChart = new Chart("myChart", {
    type: "scatter",
    data: data,
    options: {
      legend: {
        display: true,
        labels: {
          fontSize: 16,
          fontColor: 'white'
        }
      },
      spanGaps: true,
      scales: {
        xAxes: [{
          type: 'linear',
          scaleLabel: {
            display: true,
            labelString: 'True wind angle (TWA)',
            fontColor: 'white',
            fontSize: 16
          },
          ticks: {
            display: true,
            fontColor: 'white',
            fontSize: 16,
          }, 
          gridLines: {
            color: 'rgba(180,180,180,0.7)',
            lineWidth: 1
          }
        }],
        yAxes: [{
          type: 'linear',
          scaleLabel: {
            display: true,
            labelString: 'Target boat speed (POL SPD)',
            fontColor: 'white',
            fontSize: 14
          },
          ticks: {
            display: true,
            fontColor: 'white',
            fontSize: 14,
          }, 
          gridLines: {
            color: 'rgba(180,180,180,0.7)',
            lineWidth: 1
          }
        }],
      },
      tooltips: {
        enabled: true,
        callbacks: {
          label: function (tooltipItems, data) {
            let label = tooltipItems.xLabel + "Â° " + tooltipItems.yLabel + " kts"
            return label
          }
        },
        backgroundColor: '#666',
        titleFontSize: 18,
        titleFontColor: '#0066ff',
        bodyFontColor: '#ddd',
        bodyFontSize: 18,
        displayColors: false
      }
    }
  })

  var ctx = document.getElementById("myChart")
  ctx.style.backgroundColor = 'rgba(0,0,0,0.8)'
  ctx.style.fontColor = 'white'
}


function connect () {
  console.log("connect()")
  ws = new WebSocket((window.location.protocol === 'https:' ? 'wss' : 'ws') + "://" + window.location.host + "/signalk/v1/stream?subscribe=none");
  ws.onopen = function() {
    startListeners();
    ws.onmessage = function(event) {
      if (event.data.includes('signalk-server')) {
        console.log("Skipping welcome message")
      } else {
        handleData(JSON.parse(event.data));
      }
    }
    ws.onclose = function() { setTimeout(connect, 500) }
    ws.onerror = function(err) { setTimeout(connect, 500) }
  }
}

window.addEventListener('focus', function () {
  if (ws.readyState == 0) {
    connect()
  }
})

function startListeners () {
  var paths = [
    {'path': 'environment.wind.angleTrueWaterDamped'}, 
    {'path': 'performance.polarSpeed'}, 
    {'path': 'performance.boatSpeedDamped'},
    {'path': 'environment.wind.speedTrue'} 
  ]

  var subscriptionObject = {
    "context": "vessels.self",
    "policy" : "ideal",
    "minPeriod": 1000, 
    "subscribe": paths
  }

  ws.send(JSON.stringify(subscriptionObject));
}

function handleData (data) {
  if (typeof data.updates[0].meta != 'undefined') return
  
  var path = data.updates[0].values[0].path
  var value = data.updates[0].values[0].value

  if (path == 'performance.polarSpeed') {
    polarSpeed = roundDec(msToKts(value), 1)
    chartData.datasets[0].data[0].y = polarSpeed
  } else if (path == 'environment.wind.angleTrueWaterDamped') {
    TWA = roundDec(Math.abs(radToDeg(value)),1)
    chartData.datasets[0].data[0].x = TWA
    chartData.datasets[1].data[0].x = TWA
  } else if (path == 'performance.boatSpeedDamped') {
    boatSpeed = roundDec(msToKts(value),1)
    chartData.datasets[1].data[0].y = boatSpeed
  } else if (path == 'environment.wind.speedTrue') {
    TWS = msToKts(value);
  }
}


connect()

setInterval(updateChart, 300)

function updateChart () {
  if (myChart) {
    interpolateColors(TWS);
    myChart.update();
  }
}

// --- Interpolate Colors ---
function interpolateColors(tws) {
  if (!tws || !chartData) return;

  for (var i = 2; i < chartData.datasets.length; i++) {
    var dataset = chartData.datasets[i];
    var lineSpeed = parseFloat(dataset.label); 
    
    if (isNaN(lineSpeed)) continue;

    var originalColor = dataset._originalColor; 
    
    // Safety Fallback: If original color is missing, use default
    if (!originalColor) {
        originalColor = "rgba(100,100,100,0.5)";
        dataset._originalColor = originalColor;
    }

    var diff = Math.abs(tws - lineSpeed);
    var influenceRange = 2.5; 
    var weight = Math.max(0, 1 - (diff / influenceRange));

    if (weight < 0.05) {
        dataset.borderColor = originalColor;
        dataset.borderWidth = 1;
        dataset.pointBorderColor = originalColor; 
        dataset.pointBackgroundColor = originalColor;
    } else {
        var blended = blendColors(originalColor, "#FFFFFF", weight);
        dataset.borderColor = blended;
        dataset.borderWidth = 1 + (3 * weight);
        dataset.pointBorderColor = blended;
        dataset.pointBackgroundColor = blended;
    }
  }
}

function blendColors(color1, color2, weight) {
    var c1 = parseColor(color1); 
    var c2 = parseColor(color2); 
    var r = Math.round(c1[0] + (c2[0] - c1[0]) * weight);
    var g = Math.round(c1[1] + (c2[1] - c1[1]) * weight);
    var b = Math.round(c1[2] + (c2[2] - c1[2]) * weight);
    return "rgb(" + r + "," + g + "," + b + ")";
}

function parseColor(input) {
    if (!input) return [100,100,100]; // Safety
    
    if (input.substr(0,1) == "#") {
        var col = input.slice(1);
        if (col.length == 3) col = col[0]+col[0]+col[1]+col[1]+col[2]+col[2];
        var int = parseInt(col, 16);
        return [(int >> 16) & 255, (int >> 8) & 255, int & 255];
    } 
    else if (input.substr(0,3) == "rgb") {
        var parts = input.match(/(\d+)/g);
        if (parts && parts.length >= 3) {
            return [parseInt(parts[0]), parseInt(parts[1]), parseInt(parts[2])];
        }
    }
    return [100,100,100]; 
}

function radToDeg(radians) {
  return radians * 180 / Math.PI
}

function msToKts(ms) {
  return ms * 1.94384
}

function roundDec (value, decimals) {
  if (typeof value == 'undefined') {
    return undefined
  } else {
    value = Number(value.toFixed(decimals))
    return value
  }
}

</script>


